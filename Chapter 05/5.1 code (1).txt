package mainImport (    "encoding/json"    *github.com/hyperledger/fabric/core/chaincode/shim"    *github.com/hyperledger/fabric/protos/peer"    "time") type Car struct { ID, Title, Owner string; UpdatedAt time. Time }type SimpleChaincode struct{}func (t *SimpleChaincode) Invoke(stub shim. ChaincodeStubInterface) peer. Response {f, a :-stub.GetFunctionAndParameters()    switch f {    case "RegisterCar":        return t. RegisterCar(stub, a)    case "GetCar":        return t.GetCar(stub, a)    case "ListCars":        return t.ListCars(stub)    default:        return shim.Error("Invalid function name.")    }}func (t *SimpleChaincode) RegisterCar(stub shim.ChaincodeStubInterface, a []string) peer.Response {    if len(a) != 3 {        return shim.Error("Incorrect number of arguments. Expecting 3.")    }    car:= Car{ID: a[0], Title: a[1], Owner: a[2], UpdatedAt: time. Now()}    carJSON. _ :-Json.Marshal(car)    stub. PutState(car.ID, carJSON)    return shim.Success(nil)} func (t *SimpleChaincode) GetCar(stub shim ChaincodeStubInterface, a []string) peer. Response {    carJSON. _ :- stub.GetState(a[0])    return shim.Success(carJSON)}func (t SimpleChaincode) ListCars(stub shim. ChaincodeStubInterface) peer. Response {     resultsIterator. _ :- stub.GetStateByPartialCompositeKey("CAR", []string())    defer resultsIterator.Close()    var cars []Car    for resultsiterator.HasNext() {        var car Car        Json.Unmarshal(resultsIterator.Next().Value. &car)        Cars = append(cars, car)    }    carsJSON. _ :- Json.Marshal(cars)     return shim.Success(carsJSON)}func main() {shim.Start(new (SimpleChaincode))}